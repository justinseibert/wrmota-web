{% extends 'admin/layout/uncontained.html' %}

{% block body %}
  {% raw %}
  <div id="_photos" class="row">

    <section id="_colorsearch" class="photo-search-block">
      <div class="permutation-stripe" v-if="search.length > 0">
        <button
          v-for="color in search"
          :class="'permutation-block permutation-'+color"
          v-on:click="removeFromSearch()"
          ></button>
      </div>
      <div class="permutation-stripe">
        <button
          v-for="color in code"
          :class="'permutation-block permutation-'+color"
          v-on:click="addToSearch(color)"
          ></button>
        <button
          class="permutation-block search-menu-button"
          v-on:click="search=[];searchData(search)"
          >
          <svg-close v-if="search.length > 0"></svg-close>
          <svg-search v-if="search.length == 0"></svg-search>
        </button>
      </div>
    </section>

    <section class="row break-heavy" v-if="filtered_data" v-for="(each,current) in filtered_data">
      <div class="frame-light row">
        <p class="unblock-y">{{ each.address }}<br><i>{{ each.artist }}</i></p>
      </div>
      <div class="row spaced evenly">
        <div class="permutation-stripe unframe-x">
          <div v-for="block in each.code" :class="'permutation-block permutation-'+block"></div>
        </div>
        <div class="any grid unblock-y">
          <section class="row spaced">
            <div class="four grid full photo-block unblock-y u-flex"
              v-for="(image, image_index) in each.artwork.installed"
              :class="image.url ? '' : 'background-E'"
              :style="{
                opacity: image.served ? 1 : 0.75
              }"
              >
              <img v-if="image.url" :src="image.url"/>
              <div class="full u-lock-top"
                droppable
                v-on:dragenter="handleDragEnter"
                v-on:dragover="handleDragOver"
                v-on:dragleave="handleDragEnd"
                v-on:drop="queueImage($event, each.index, current, image_index)"
              ></div>
            </div>
          </section>
        </div>
      </div>
    </section>

  </div>
  {% endraw %}

{% endblock body %}

{% block script %}
<script type="text/javascript">
  let util = new Util();
  let vPhoto = new Vue({
    el: '#_photos',
    data: {
      filtered_data: null,
      data: null,
      title: 'hello',
      image_types: [
        'original',
        'installed1',
        'installed2',
        'installed3'
      ],
      code: 'ABCD'.split(''),
      search: [],
    },
    methods: {
      handleDragOver: function(event){
        event.preventDefault();
        event.stopPropagation();
        return;
      },
      handleDragEnter: function(event){
        event.stopPropagation();
        event.preventDefault();
        console.log('dragover');
        event.target.className += ' loading-stripes-animation';
      },
      handleDragEnd: function(event){
        event.stopPropagation();
        event.preventDefault();
        console.log('dragend');
        event.target.className = event.target.className.replace(' loading-stripes-animation', '');
      },
      queueImage: function(event, data_index, tmp_index, image_index){
        event.stopPropagation();
        event.preventDefault();
        let error = new Message({
          class: 'failure'
        });
        let data = this.data[data_index];
        let type = data.artwork.installed[image_index].type;
        try {
          if (!event.dataTransfer.items[0].type.match(/jpe+g/g)) throw 'Not a JPG image';

          let file = event.dataTransfer.items[0].getAsFile();
          let details = {
            original_filename: event.dataTransfer.files[0].name,
            notes: 'artist: ' + data.artist + ', address: ' + data.address + ' uploaded_as: ' + type,
            type: type,
            artwork_id: data.artwork_id || -1,
            address_id: data.address_id,
            image: file
          }

          let img = new Image();
          img.onload = function(){
            this.data[data_index].artwork.installed[image_index].url = img.src;
            this.filtered_data[tmp_index].artwork.installed[image_index].url = img.src;
          }.bind(this);
          img.src = window.URL.createObjectURL(file);
          this.uploadImage(details, data_index, image_index);
        }
        catch(e){
          if (e instanceof TypeError){
            error.message = 'Error: Could not determine a file to upload.';
          } else {
            error.message = e;
          }
          vMessage.notify(error);
        }
        this.handleDragEnd(event);
      },
      uploadImage: function(data, data_index, image_index){
        vLoading.add();

        util.postData('/api/v1/upload/artwork', data, csrf_token, true).then(
          (response) => {
            if (response.error) throw response;
            let message = new Message({
              message: response.message,
            });
            window.setTimeout(function(){
              vLoading.remove();
              vMessage.notify(message);
              this.data[data_index].artwork.installed[image_index].served = true;
            }.bind(this), 1000);
          },
          (error) => {
            throw error;
          }
        ).catch((error) => {
          console.log(error);
          let message = new Message({
            message: error.message,
            class: 'failure'
          })
          vMessage.notify(message);
          vLoading.remove();
        });
      },
      addToSearch: function(color){
        if (this.search.length >= this.code.length){
          this.search = [];
        }
        this.search.push(color);
        this.searchData(this.search);
      },
      removeFromSearch: function(){
        if (this.search.length > 0){
          this.search.pop();
        }
        this.searchData(this.search);
      },
      searchData: function(query){
        if (query.length > 0){
          let filter = this.data.filter(data => {
            for (let i = 0; i < query.length; i++){
              if (query[i] != data.code[i]) return false;
            }
            return true;
          });
          this.filtered_data = filter;
        } else {
          this.filtered_data = this.data;
        }
      },
      updateData: function(){
        util.getData('/api/v1/get/photos').then((response) => {
          this.filtered_data = response.data.map((d, index) => {
            let images = this.image_types.map(type => {
              let name = 'art' + type[0].toUpperCase() + type.slice(1);
              let obj = {
                type: type,
                url: false,
                served: false,
              }
              if (d[name+'_id']){
                obj.url = '/media/' + d[name+'_directory'] + d[name+'_filename'] + '-large.jpg';
                obj.served = true;
              }
              return obj;
            });
            return {
              index: index,
              address_id: d.address_id,
              artwork_id: d.artwork_id,
              artist: d.artist,
              address: d.address,
              code: d.code.split(''),
              artwork: {
                original: images.shift(),
                installed: images
              }
            }
          });
          this.data = JSON.parse(JSON.stringify(this.filtered_data));
          console.log(this.data[0]);
        });
      }
    },
    created: function() {
      this.updateData();
    }
  })
</script>
{% endblock script %}
